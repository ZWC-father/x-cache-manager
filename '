#include "redis_base.h"
#include "redis_adapter.h"
#include <variant>

class RedisLRU{
public:
    struct CacheLRU{
        std::string key;
        size_t size;
        uint64_t download_time;
        std::vector<char> hash;
        int64_t sequence;

        CacheLRU(const std::string& key, size_t size, uint64_t download_time,
                 const std::vector<char> &hash, int64_t sequence = 0) : key(key), size(size),
                 download_time(download_time), hash(hash), sequence(sequence) {}
    };

    struct MetaLRU{
        size_t cache_size, max_size;
        int64_t sequence;
        MetaLRU(size_t cache_size, size_t max_size, int64_t sequence) : cache_size(cache_size),
        max_size(max_size), sequence(sequence) {}
    };


    RedisLRU(const std::shared_ptr<Logger>& logger,
             const std::shared_ptr<RedisAdapter>& redis) :
             redis(redis), logger(logger) {
        auto res = redis->command_single<int>("EXISTS lru_meta");
        if(!std::holds_alternative<int>(res)){
            throw RedisError("unknown redis error");
        }

        if(std::get<int>(res) == 1){
            _new = false;
        }else{
            _new = true;
        }
    }

    bool is_new() const {return _new;}

    void init_db(const MetaLRU& meta){
        auto res = redis->command_single<int>("HSET lru_meta cache_size %s", std::to_string(meta.cache_size));
       
    }
   
    int insert_lru(const CacheLRU& entry){
        auto res = redis->command_single<int>("HSET lru_seq");
        check_error(res);
        if(!check_val<RedisAdapter::RedisReplyInteger>(res, {1}))
        
    }

    bool _new;

private:
    std::shared_ptr<RedisAdapter> redis;
    std::shared_ptr<Logger> logger;

    void check_error(const auto& res){
        if(std::holds_alternative<RedisAdapter::RedisReplyError>(res)){
            throw RedisError("redis command error: " + std::get<RedisAdapter::RedisReplyError>(res).str);
        }
    }

    template<typename T>
    bool check_value(const auto& res, const T& expection){
        if(auto *ptr = std::get_if<T>(res)){
            return *ptr == expection;
        }
        return false;
    }
   
};
